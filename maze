#!/usr/bin/env bash

# Maze board array members
# [0] Width of board, in cells.
# [1] Height of board, in cells.
# [2] Board data, stored as a large string.
# [3] Starting X
# [4] Starting Y
# [5] Ending X
# [6] Ending Y

# Position array
# [0] X position, in cells
# [1] Y position, in cells
# [2] Direction facing (0=North, 1=East, 2=South, 3=West

# Disable warning about escaping a single quote
# shellcheck disable=SC1003

# shellcheck disable=SC1091
. bpm
bpm::include ansi
bpm::include array
bpm::include assign
bpm::include readkey

# Pick a spot in the maze near the edge as a start.
# Dig tunnels all over.
#
# $1 - Destination variable name for the board array.
# $2 - Board X (width in cells)
# $3 - Board Y (height in cells)
# $4 - Board data
maze::carvePaths() {
    local board boardX boardY center coords coordX coordY delta lastX lastY leftToCheck minX minY rowSize startX startY validPaths

    boardX=$2
    boardY=$3
    board=$4

    rowSize=$((boardX * 2 + 1))

    case "$((RANDOM % 4))" in
        0)
            startX=$((RANDOM % boardX))
            startY=0
            ;;

        1)
            startX=$((boardX - 1))
            startY=$((RANDOM % boardY))
            ;;

        2)
            startX=$((RANDOM % boardX))
            startY=$((boardY - 1))
            ;;

        3)
            startX=0
            startY=$((RANDOM % boardY))
            ;;
    esac

    leftToCheck=("$startX,$startY")
    minX=$((boardX - 1))
    minY=$((boardY - 1))

    while [[ "${#leftToCheck[@]}" -gt 0 ]]; do
        random=$((RANDOM % ${#leftToCheck[@]}))
        coords=${leftToCheck[random]}
        coordX=${coords%,*}
        coordY=${coords#*,}
        leftToCheck=("${leftToCheck[@]:0:random}" "${leftToCheck[@]:random + 1}")
        validPaths=()
        center=$((coordY * rowSize * 2 + rowSize + coordX * 2 + 1))

        if [[ $coordX != 0 ]] && maze::isValidPath "$center" "$rowSize" "-1" "$board"; then
            validPaths[${#validPaths[@]}]="-1,0"
        fi

        if [[ $coordX != "$minX" ]] && maze::isValidPath "$center" "$rowSize" "1" "$board"; then
            validPaths[${#validPaths[@]}]="1,0"
        fi

        if [[ $coordY != 0 ]] && maze::isValidPath "$center" "$rowSize" "-$rowSize" "$board"; then
            validPaths[${#validPaths[@]}]="0,-1"
        fi

        if [[ $coordY != "$minY" ]] && maze::isValidPath "$center" "$rowSize" "$rowSize" "$board"; then
            validPaths[${#validPaths[@]}]="0,1"
        fi

        case "${#validPaths[@]}" in
            2|3)
                # If there's other options, put this back in the list for later processing
                leftToCheck[${#leftToCheck[@]}]=$coords
                ;&

            1)
                random=$((RANDOM % ${#validPaths[@]}))
                delta=${validPaths[random]}
                center=$((center + ${delta#*,} * rowSize + ${delta%,*}))
                board=${board:0:center}' '${board:center + 1}
                lastX=$((coordX + ${delta%,*}))
                lastY=$((coordY + ${delta#*,}))
                leftToCheck[${#leftToCheck[@]}]=$lastX,$lastY
        esac
    done

    local "$1" && assign::array "$1" "$boardX" "$boardY" "$board" "$startX" "$startY" "$lastX" "$lastY"
}


# See if the player made their way to the exit.
#
# $1 - Exit coords "X,Y" in cells
# $2 - Number of moves.
# $3-$5 - Player data (x, y, direction)
#
# Returns true if the user found the exit.
maze::checkForExit() {
    if [[ "$3,$4" == "$1" ]]; then
        echo ""
        echo "Congratulations! You found your way out in $2 moves."

        return 0
    fi

    return 1
}


# Determine the corridor edges
#
# $1 - Variable to get the edges array
# $2 - The view
maze::corridorPortions() {
    local left right

    case "${2:0:2}" in
        "  ")
            left=('_ ' ' |' '_|' '  ')
            ;;

        " X")
            left=('__' '  ' '__' '  ')
            ;;

        "X ")
            left=('\ ' '  ' '  ' '/ ')
            ;;

        "XX")
            left=('\ ' ' |' ' |' '/ ')
            ;;
    esac

    case "${2:1:2}" in
        "  ")
            right=(' _' '| ' '|_' '  ')
            ;;

        " X")
            right=(' /' '  ' '  ' ' \')
            ;;

        "X ")
            right=('__' '  ' '__' '  ')
            ;;

        "XX")
            right=(' /' '| ' '| ' ' \')
            ;;
    esac

    local "$1" && assign::array "$1" "${left[@]}" "${right[@]}"
}


# Determines if it is acceptable to make a path connecting two cells.
#
# $1 - Index in the board data for the cell where we start
# $2 - The computed size of one row
# $3 - The amount of change in X
# $4 - The amount of change in Y
# $5 - Board data
#
# Returns true (0) when these two cells can be connected. Any other value
# indicates they should not be connected.
maze::isValidPath() {
    local centerIndex delta index rowSize

    centerIndex=$1
    rowSize=$2
    delta=$3
    board=$4
    shift 4

    # Move to the wall
    index=$((centerIndex + delta))

    if [[ "${board:index:1}" == " " ]]; then
        # Already a path in this direction
        return 1
    fi

    # Move to the middle of the tile we want to check
    index=$((index + delta))

    if [[ "${board:index - 1:1}${board:index + 1:1}${board:index - rowSize:1}${board:index + rowSize:1}" == *" "* ]]; then
        # Adjacent cell is already connected
        return 1
    fi

    return 0
}


# Look around from a specific cell.
#
# $1 - Destination variable name to get a string.
# $2 - Position X in cells.
# $3 - Postiion Y in cells.
# $4 - Direction to look (0=north, 1=east, 2=south, 3=west)
# $5 - Board width in cells.
# $6 - Board data.
#
# Provides a string with three characters - left wall, forward wall, right
# wall. Walls are replaced with X.
maze::lookAround() {
    local board e index n rowSize s view w x y

    x=$2
    y=$3
    rowSize=$((1 + $5 * 2))
    board=$6
    index=$((rowSize + y * rowSize * 2 + x * 2 + 1))
    n=${board:index - rowSize:1}
    s=${board:index + rowSize:1}
    w=${board:index - 1:1}
    e=${board:index + 1:1}

    case "$4" in
        0)
            view="$w$n$e"
            ;;

        1)
            view="$n$e$s"
            ;;

        2)
            view="$e$s$w"
            ;;

        3)
            view="$s$w$n"
            ;;
    esac

    view=${view//|/X}
    view=${view//-/X}

    local "$1" && assign::value "$1" "$view"
}


# Creates a maze board array structure. Does not connect cells.
#
# $1 - Destination variable name for the board array
# $2 - Width of board in cells
# $3 - Height of board in cells
maze::makeMazeBoard() {
    local board cells divider rowsLeft x y

    x=$2
    y=$3
    rowsLeft=$3

    maze::makeMazeLine divider "$x" "+" "-+"
    maze::makeMazeLine cells "$x" "|" " |"
    board="$divider"

    while [[ $rowsLeft -gt 0 ]]; do
        rowsLeft=$((rowsLeft - 1))
        board+="$cells$divider"
    done

    local "$1" && assign::array "$1" "$x" "$y" "$board"
}


# Creates a single line of a maze board.
#
# $1 - Destination variable name.
# $2 - Length of line in cells.
# $3 - Starting string for the line.
# $4 - String to append for each cell.
maze::makeMazeLine() {
    local len line

    len=$2
    line=$3

    while [[ $len -gt 0 ]]; do
        len=$((len - 1))
        line+=$4
    done

    local "$1" && assign::value "$1" "$line"
}


# Creates a maze board array, complete with tunnels, the start point and end
# point.
#
# $1 - Destination variable name for the board data.
# $2 - Width of board in cells.
# $3 - Height of board in cells.
maze::makeMaze() {
    local boardData
    # local result startPos

    # Width and height in the number of cells
    maze::makeMazeBoard boardData "$2" "$3"

    # Make corridors
    maze::carvePaths boardData "${boardData[@]}"

    local "$1" && assign::array "$1" "${boardData[@]}"
}


# Attempt to move the player in the indicated direction.
#
# $1 - Destination variable name for the position data.
# $2 - Move direction, either 1 or -1
# $3-$5 - Position data
# $6-$@ - Board data
maze::move() {
    local board boardX index moveX moveY playerDir playerX playerY rowSize stepDir target

    target=$1
    stepDir=$2
    playerX=$3
    playerY=$4
    playerDir=$5
    boardX=$6
    board=$8
    rowSize=$((boardX * 2 + 1))
    index=$((rowSize + playerY * rowSize * 2 + playerX * 2 + 1))

    case "$playerDir" in
        0)
            moveX=0
            moveY=$((- stepDir))
            ;;

        1)
            moveX=$stepDir
            moveY=0
            ;;

        2)
            moveX=0
            moveY=$stepDir
            ;;

        3)
            moveX=$((- stepDir))
            moveY=0
            ;;
    esac

    if [[ "${board:index + rowSize * moveY + moveX:1}" != " " ]]; then
        return 1
    fi

    playerX=$((playerX + moveX))
    playerY=$((playerY + moveY))

    local "$target" && assign::array "$target" "$playerX" "$playerY" "$playerDir"
    return 0
}


# Reads a key from the keyboard and maps it to a code.
#
# $1 - Destination variable name for the code.
maze::readKey() {
    local code key

    readkey::code key

    case "$key" in
        # Arrow, vi, vi+shift, wasd, wasd+shift, numberPad
        ARROW_UP|k|K|w|W|8)
            code=FORWARD
            ;;

        ARROW_LEFT|h|H|a|A|4)
            code=LEFT
            ;;

        ARROW_RIGHT|l|L|d|D|6)
            code=RIGHT
            ;;

        ARROW_DOWN|j|J|s|S|5|2)
            code=BACK
            ;;

        "?")
            code=HELP
            ;;

        ESCAPE|q|Q|x|X|$'\x18')
            code=EXIT
            ;;

        *)
            code=UNKNOWN
            ;;
    esac

    local "$1" && assign::value "$1" "$code"
}


# Sets the initial position for the player
#
# $1 - Destination variable name for the position data array.
# $2-$@ - The board information
maze::setInitialPosition() {
    local board boardX boardY dir directions index offset offsetList random rowSize spot startX startY

    boardX=$2
    boardY=$3
    board=$4
    startX=$5
    startY=$6
    rowSize=$((1 + boardX * 2))
    index=$((rowSize + startY * 2 * rowSize + 1 + startX * 2))
    directions=0123

    while true; do
        random=$((RANDOM % ${#directions}))
        dir=${directions:random:1}
        offsetList=("-$rowSize" 1 "$rowSize" -1)
        offset=${offsetList[dir]}
        spot=${board:index + offset:1}

        if [[ "$spot" == " " ]]; then
            local "$1" && assign::array "$1" "$startX" "$startY" "$dir"
            return
        fi

        directions="${directions:0:random}${directions:random + 1}"
    done
}


# Display a maze board.
#
# $@ - The maze board array, optionally followed by the position array.
maze::showBoardData() {
    local board exitColor index line lines marker markerColor rowSize startColor x y

    x=$1
    board=$3
    rowSize=$((2 * x + 1))
    lines=()

    while [[ -n "$board" ]]; do
        lines[${#lines[@]}]=${board:0:rowSize}
        board=${board:rowSize}
    done

    if [[ -n "$8" ]]; then
        # Position array
        marker="^>v<"
        marker=${marker:${10}:1}
        y=$((1 + $9 * 2))
        lines[$y]="${lines[y]:0:1 + $8 * 2}$marker${lines[y]:2 + $8 * 2}"
    elif [[ -n "$4" ]]; then
        # Starting position
        y=$((1 + $5 * 2))
        lines[$y]="${lines[y]:0:1 + $4 * 2}*${lines[y]:2 + $4 * 2}"
    fi

    if [[ -n "$6" ]]; then
        y=$((1 + $7 * 2))
        lines[$y]="${lines[y]:0:1 + $6 * 2}X${lines[y]:2 + $6 * 2}"
    fi

    if [[ -n "$marker" ]]; then
        markerColor=$(ansi --no-newline --bg-blue --yellow --bold "$marker")
    else
        # Does not match anything
        marker="XXX"
        markerColor="XXX"
    fi

    startColor=$(ansi --no-newline --yellow --bold "*")
    exitColor=$(ansi --no-newline --green --bold X)

    for line in "${lines[@]}"; do
        line=${line/$marker/$markerColor}
        line=${line/\*/$startColor}
        line=${line/X/$exitColor}
        echo "$line"
    done
}


# Display the in-maze view
#
# $1-$3 - The positional data
# $4-$@ - The board data
maze::showCorridor() {
    local corridor deltaX deltaY line

    case "$3" in
        0)
            deltaX=0
            deltaY=-1
            ;;

        1)
            deltaX=1
            deltaY=0
            ;;

        2)
            deltaX=0
            deltaY=1
            ;;

        3)
            deltaX=-1
            deltaY=0
            ;;
    esac

    maze::showCorridor4 corridor "$1" "$2" "$3" "$4" "$6" "$deltaX" "$deltaY"

    for line in "${corridor[@]}"; do
        echo "$line"
    done
}


# Show the farthest point the user can see.
#
# $1 - Destination variable for the corridor array
# $2 - Position X in cells.
# $3 - Postiion Y in cells.
# $4 - Direction to look (0=north, 1=east, 2=south, 3=west)
# $5 - Board width in cells.
# $6 - Board data.
maze::showCorridor1() {
    local bits lines view target

    target=$1
    shift
    maze::lookAround view "$@"
    echo "view1: ...$view..."
    maze::corridorPortions bits "$view"

    case "${view:1:1}" in
        " ")
            lines=(
                "${bits[0]}"'   '"${bits[4]}"
                "${bits[1]}"'\ /'"${bits[5]}"
                "${bits[2]}"'/ \'"${bits[6]}"
                "${bits[3]}"'   '"${bits[7]}"
            )
            ;;

        X)
            lines=(
                "${bits[0]}___${bits[4]}"
                "${bits[1]}   ${bits[5]}"
                "${bits[2]}___${bits[6]}"
                "${bits[3]}   ${bits[7]}"
            )
            ;;
    esac

    local "$target" && assign::array "$target" "${lines[@]}"
}


# Show one step away from the farthest point the user can see.
#
# $1 - Destination variable for the corridor array
# $2 - Position X in cells.
# $3 - Postiion Y in cells.
# $4 - Direction to look (0=north, 1=east, 2=south, 3=west)
# $5 - Board width in cells.
# $6 - Board data.
# $7 - Delta X for traveling forward.
# $8 - Delta Y for traveling forward.
maze::showCorridor2() {
    local bits c lines view

    maze::lookAround view "$2" "$3" "$4" "$5" "$6"
    echo "view2: ...$view..."

    if [[ "${view:1:1}" == "X" ]]; then
        c=(
            '_______'
            '       '
            '       '
            '       '
            '_______'
            '       '
        )
    else
        maze::showCorridor1 c "$(($2 + $7))" "$(($3 + $8))" "$4" "$5" "$6"
        c=('       ' "${c[@]}" '       ')
    fi

    maze::corridorPortions bits "$view"
    lines=(
        "${bits[0]}${c[0]}${bits[4]}"
        "${bits[1]}${c[1]}${bits[5]}"
        "${bits[1]}${c[2]}${bits[5]}"
        "${bits[1]}${c[3]}${bits[5]}"
        "${bits[2]}${c[4]}${bits[6]}"
        "${bits[3]}${c[5]}${bits[7]}"
    );

    local "$1" && assign::array "$1" "${lines[@]}"
}


# Show two steps away from the farthest point the user can see.
#
# $1 - Destination variable for the corridor array
# $2 - Position X in cells.
# $3 - Postiion Y in cells.
# $4 - Direction to look (0=north, 1=east, 2=south, 3=west)
# $5 - Board width in cells.
# $6 - Board data.
# $7 - Delta X for traveling forward.
# $8 - Delta Y for traveling forward.
maze::showCorridor3() {
    local bits c lines view

    maze::lookAround view "$2" "$3" "$4" "$5" "$6"
    echo "view3: ...$view..."

    if [[ "${view:1:1}" == "X" ]]; then
        c=(
            '___________'
            '           '
            '           '
            '           '
            '           '
            '           '
            '___________'
            '           '
        )
    else
        maze::showCorridor2 c "$(($2 + $7))" "$(($3 + $8))" "$4" "$5" "$6" "$7" "$8"
        c=('           ' "${c[@]}" '           ')
    fi

    maze::corridorPortions bits "$view"
    lines=(
        "${bits[0]}${c[0]}${bits[4]}"
        "${bits[1]}${c[1]}${bits[5]}"
        "${bits[1]}${c[2]}${bits[5]}"
        "${bits[1]}${c[3]}${bits[5]}"
        "${bits[1]}${c[4]}${bits[5]}"
        "${bits[1]}${c[5]}${bits[5]}"
        "${bits[2]}${c[6]}${bits[6]}"
        "${bits[3]}${c[7]}${bits[7]}"
    );

    local "$1" && assign::array "$1" "${lines[@]}"
}


# Show three steps away from the farthest point the user can see.
#
# $1 - Destination variable for the corridor array
# $2 - Position X in cells.
# $3 - Postiion Y in cells.
# $4 - Direction to look (0=north, 1=east, 2=south, 3=west)
# $5 - Board width in cells.
# $6 - Board data.
# $7 - Delta X for traveling forward.
# $8 - Delta Y for traveling forward.
maze::showCorridor4() {
    local bits c lines view

    maze::lookAround view "$2" "$3" "$4" "$5" "$6"
    echo "view4: ...$view..."

    if [[ "${view:1:1}" == "X" ]]; then
        c=(
            '_______________'
            '               '
            '               '
            '               '
            '               '
            '               '
            '               '
            '               '
            '_______________'
            '               '
        )
    else
        maze::showCorridor3 c "$(($2 + $7))" "$(($3 + $8))" "$4" "$5" "$6" "$7" "$8"
        c=('               ' "${c[@]}" '               ')
    fi

    maze::corridorPortions bits "$view"
    lines=(
        "${bits[0]}${c[0]}${bits[4]}"
        "${bits[1]}${c[1]}${bits[5]}"
        "${bits[1]}${c[2]}${bits[5]}"
        "${bits[1]}${c[3]}${bits[5]}"
        "${bits[1]}${c[4]}${bits[5]}"
        "${bits[1]}${c[5]}${bits[5]}"
        "${bits[1]}${c[6]}${bits[5]}"
        "${bits[1]}${c[7]}${bits[5]}"
        "${bits[2]}${c[8]}${bits[6]}"
        "${bits[3]}${c[9]}${bits[7]}"
    );

    local "$1" && assign::array "$1" "${lines[@]}"
}


# Turns the character 90 degrees
#
# $1 - Destination variable for the new position
# $2 - Turn direction, -1 is left and 1 is right
# $3-$@ - Position array elements
maze::turn() {
    local dir

    dir=$(($5 + $2))

    case "$dir" in
        -1)
            dir=3
            ;;
        4)
            dir=0
            ;;
    esac

    local "$1" && assign::array "$1" "$3" "$4" "$dir"
}


maze() {
    local board displaySize exitCoords moves position topDown

    maze::makeMaze board 20 10
    maze::setInitialPosition position "${board[@]}"
    topDown=false

    if $topDown; then
        maze::showBoardData "${board[@]}" "${position[@]}"
        displaySize=$((board[1] * 2 + 1))
    else
        maze::showCorridor "${position[@]}" "${board[@]}"
        displaySize=10
    fi
    echo "$displaySize" # FIXME

    exitCoords="${board[5]},${board[6]}"
    moves=0

    while maze::readKey key; do
        case "$key" in
            FORWARD)
                maze::move position 1 "${position[@]}" "${board[@]}" && moves=$((moves + 1))
                maze::checkForExit "$exitCoords" "$moves" "${position[@]}" && return
                # ansi::up "$displaySize"
                ;;

            LEFT)
                # ansi::up "$displaySize"
                maze::turn position -1 "${position[@]}"
                ;;

            RIGHT)
                # ansi::up "$displaySize"
                maze::turn position 1 "${position[@]}"
                ;;

            BACK)
                maze::move position -1 "${position[@]}" "${board[@]}" && moves=$((moves + 1))
                maze::checkForExit "$exitCoords" "$moves" "${position[@]}" && return
                # ansi::up "$displaySize"
                ;;

            HELP)
                # ansi::up "$displaySize"
                ansi::eraseDisplay 0
                echo ""
                echo "Navigate through the maze. Try to find the exit."
                echo ""
                echo "Up, W, K, 8 = Move forward."
                echo "Down, S, J, 5, 2 = Move backward."
                echo "Left, A, H, 4 = Turn left."
                echo "Right, D, L, 6 = Turn right."
                echo "Escape, Q, X = Leave game."
                echo ""
                ;;

            EXIT)
                echo ""
                echo "Thanks for playing!"

                return
                ;;

            UNKNOWN)
                # ansi::up "$displaySize"
                ansi::eraseDisplay 0
                echo ""
                echo "Sorry, I do not understand that command. Press ? for help."
                echo ""
                ;;
        esac

        if $topDown; then
            maze::showBoardData "${board[@]}" "${position[@]}"
        else
            maze::showBoardData "${board[@]}" "${position[@]}"
            maze::showCorridor "${position[@]}" "${board[@]}"
        fi
    done
}


if ! bpm::isSourced; then
    # Disabling locale settings makes this marginally faster
    LC_ALL=C LANG=C maze "$@"
fi
