#!/usr/bin/env bash

# Maze board array members
# [0] Width of board, in cells.
# [1] Height of board, in cells.
# [2] Board data, stored as a large string.
# [3] Starting X
# [4] Starting Y
# [5] Ending X
# [6] Ending Y

# Position array
# [0] X position, in cells
# [1] Y position, in cells
# [2] Direction facing (N, S, E, W)

# shellcheck disable=SC1091
. bpm
bpm::include ansi
bpm::include array
bpm::include assign
bpm::include readkey


# Pick a spot in the maze near the edge as a start.
# Dig tunnels all over.
#
# $1 - Destination variable name for the board array.
# $2 - Board X (width in cells)
# $3 - Board Y (height in cells)
# $4 - Board data
maze::carvePaths() {
    local board boardX boardY center coords coordX coordY delta lastX lastY leftToCheck minX minY rowSize startX startY validPaths

    boardX=$2
    boardY=$3
    board=$4

    rowSize=$((boardX * 2 + 1))

    case "$((RANDOM % 4))" in
        0)
            startX=$((RANDOM % boardX))
            startY=0
            ;;

        1)
            startX=$((boardX - 1))
            startY=$((RANDOM % boardY))
            ;;

        2)
            startX=$((RANDOM % boardX))
            startY=$((boardY - 1))
            ;;

        3)
            startX=0
            startY=$((RANDOM % boardY))
            ;;
    esac

    leftToCheck=("$startX,$startY")
    minX=$((boardX - 1))
    minY=$((boardY - 1))

    while [[ "${#leftToCheck[@]}" -gt 0 ]]; do
        random=$((RANDOM % ${#leftToCheck[@]}))
        coords=${leftToCheck[random]}
        coordX=${coords%,*}
        coordY=${coords#*,}
        leftToCheck=("${leftToCheck[@]:0:random}" "${leftToCheck[@]:random + 1}")
        validPaths=()
        center=$((coordY * rowSize * 2 + rowSize + coordX * 2 + 1))

        if [[ $coordX != 0 ]] && maze::isValidPath "$center" "$rowSize" "-1" "$board"; then
            validPaths[${#validPaths[@]}]="-1,0"
        fi

        if [[ $coordX != "$minX" ]] && maze::isValidPath "$center" "$rowSize" "1" "$board"; then
            validPaths[${#validPaths[@]}]="1,0"
        fi

        if [[ $coordY != 0 ]] && maze::isValidPath "$center" "$rowSize" "-$rowSize" "$board"; then
            validPaths[${#validPaths[@]}]="0,-1"
        fi

        if [[ $coordY != "$minY" ]] && maze::isValidPath "$center" "$rowSize" "$rowSize" "$board"; then
            validPaths[${#validPaths[@]}]="0,1"
        fi

        case "${#validPaths[@]}" in
            2|3)
                # If there's other options, put this back in the list for later processing
                leftToCheck[${#leftToCheck[@]}]=$coords
                ;&

            1)
                random=$((RANDOM % ${#validPaths[@]}))
                delta=${validPaths[random]}
                center=$((center + ${delta#*,} * rowSize + ${delta%,*}))
                board=${board:0:center}' '${board:center + 1}
                lastX=$((coordX + ${delta%,*}))
                lastY=$((coordY + ${delta#*,}))
                leftToCheck[${#leftToCheck[@]}]=$lastX,$lastY
        esac
    done

    local "$1" && assign::array "$1" "$boardX" "$boardY" "$board" "$startX" "$startY" "$lastX" "$lastY"
}


# Determines if it is acceptable to make a path connecting two cells.
#
# $1 - Index in the board data for the cell where we start
# $2 - The computed size of one row
# $3 - The amount of change in X
# $4 - The amount of change in Y
# $5 - Board data
#
# Returns true (0) when these two cells can be connected. Any other value
# indicates they should not be connected.
maze::isValidPath() {
    local centerIndex delta index rowSize

    centerIndex=$1
    rowSize=$2
    delta=$3
    board=$4
    shift 4

    # Move to the wall
    index=$((centerIndex + delta))

    if [[ "${board:index:1}" == " " ]]; then
        # Already a path in this direction
        return 1
    fi

    # Move to the middle of the tile we want to check
    index=$((index + delta))

    if [[ "${board:index - 1:1}${board:index + 1:1}${board:index - rowSize:1}${board:index + rowSize:1}" == *" "* ]]; then
        # Adjacent cell is already connected
        return 1
    fi

    return 0
}


# Creates a maze board array structure. Does not connect cells.
#
# $1 - Destination variable name for the board array
# $2 - Width of board in cells
# $3 - Height of board in cells
maze::makeMazeBoard() {
    local board cells divider rowsLeft x y

    x=$2
    y=$3
    rowsLeft=$3

    maze::makeMazeLine divider "$x" "+" "-+"
    maze::makeMazeLine cells "$x" "|" " |"
    board="$divider"

    while [[ $rowsLeft -gt 0 ]]; do
        rowsLeft=$((rowsLeft - 1))
        board+="$cells$divider"
    done

    local "$1" && assign::array "$1" "$x" "$y" "$board"
}


# Creates a single line of a maze board.
#
# $1 - Destination variable name.
# $2 - Length of line in cells.
# $3 - Starting string for the line.
# $4 - String to append for each cell.
maze::makeMazeLine() {
    local len line

    len=$2
    line=$3

    while [[ $len -gt 0 ]]; do
        len=$((len - 1))
        line+=$4
    done

    local "$1" && assign::value "$1" "$line"
}


# Creates a maze board array, complete with tunnels, the start point and end
# point.
#
# $1 - Destination variable name for the board data.
# $2 - Width of board in cells.
# $3 - Height of board in cells.
maze::makeMaze() {
    local boardData
    # local result startPos

    # Width and height in the number of cells
    maze::makeMazeBoard boardData "$2" "$3"

    # Make corridors
    maze::carvePaths boardData "${boardData[@]}"
    # maze::showBoardData "${boardData[@]}"

    local "$1" && assign::array "$1" "${boardData[@]}"
}


# Sets the initial position for the player
#
# $1 - Destination variable name for the position data array.
# $2-$@ - The board information
maze::setInitialPosition() {
    local board boardX boardY dir directions index random rowSize spot startX startY

    boardX=$2
    boardY=$3
    board=$4
    startX=$5
    startY=$6
    rowSize=$((1 + boardX * 2))
    index=$((rowSize + startY * 2 * rowSize + 1 + startX * 2))
    directions=NESW

    while true; do
        random=$((RANDOM % ${#directions}))
        dir=${directions:random:1}

        case "$dir" in
            N)
                spot=${board:index - rowSize:1}
                ;;

            E)
                spot=${board:index + 1:1}
                ;;

            S)
                spot=${board:index + rowSize:1}
                ;;

            W)
                spot=${board:index - 1:1}
                ;;
        esac

        if [[ "$spot" == " " ]]; then
            local "$1" && assign::array "$1" "$startX" "$startY" "$dir"
            return
        fi

        directions="${directions:0:random}${directions:random + 1}"
    done
}


# Display a maze board.
#
# $@ - The maze board array, optionally followed by the position array.
maze::showBoardData() {
    local board index line lines marker rowSize x y

    x=$1
    board=$3
    rowSize=$((2 * x + 1))
    lines=()

    while [[ -n "$board" ]]; do
        lines[${#lines[@]}]=${board:0:rowSize}
        board=${board:rowSize}
    done

    if [[ -n "$4" ]]; then
        case "${10-}" in
            N)
                marker="^"
                ;;

            E)
                marker=">"
                ;;

            S)
                marker="v"
                ;;

            W)
                marker="<"
                ;;

            *)
                marker="*"
                ;;
        esac

        marker=$(ansi --bg-blue --yellow --bold "$marker")

        y=$((1 + $5 * 2))
        line=${lines[$y]}
        lines[$y]="${line:0:1 + $4 * 2}$marker${line:2 + $4 * 2}"
    fi

    if [[ -n "$6" ]]; then
        marker=$(ansi --green --bold X)
        y=$((1 + $7 * 2))
        line=${lines[$y]}
        lines[$y]="${line:0:1 + $6 * 2}E${line:2 + $6 * 2}"
    fi

    for line in "${lines[@]}"; do
        echo "$line"
    done
}


maze() {
    local board position

    maze::makeMaze board 20 10
    maze::setInitialPosition position "${board[@]}"
    maze::showBoardData "${board[@]}" "${position[@]}"
    set | grep ^position=
}


if ! bpm::isSourced; then
    # Disabling locale settings makes this marginally faster
    LC_ALL=C LANG=C maze "$@"
fi
