#!/usr/bin/env bash

# Maze board array members
# [0] Width of board, in cells.
# [1] Height of board, in cells.
# [2] Board data, stored as a large string.
# [3] Starting X
# [4] Starting Y
# [5] Ending X
# [6] Ending Y

# Position array
# [0] X position, in cells
# [1] Y position, in cells
# [2] Direction facing (0=North, 1=East, 2=South, 3=West

# shellcheck disable=SC1091
. bpm
bpm::include ansi
bpm::include array
bpm::include assign
bpm::include readkey


# Pick a spot in the maze near the edge as a start.
# Dig tunnels all over.
#
# $1 - Destination variable name for the board array.
# $2 - Board X (width in cells)
# $3 - Board Y (height in cells)
# $4 - Board data
maze::carvePaths() {
    local board boardX boardY center coords coordX coordY delta lastX lastY leftToCheck minX minY rowSize startX startY validPaths

    boardX=$2
    boardY=$3
    board=$4

    rowSize=$((boardX * 2 + 1))

    case "$((RANDOM % 4))" in
        0)
            startX=$((RANDOM % boardX))
            startY=0
            ;;

        1)
            startX=$((boardX - 1))
            startY=$((RANDOM % boardY))
            ;;

        2)
            startX=$((RANDOM % boardX))
            startY=$((boardY - 1))
            ;;

        3)
            startX=0
            startY=$((RANDOM % boardY))
            ;;
    esac

    leftToCheck=("$startX,$startY")
    minX=$((boardX - 1))
    minY=$((boardY - 1))

    while [[ "${#leftToCheck[@]}" -gt 0 ]]; do
        random=$((RANDOM % ${#leftToCheck[@]}))
        coords=${leftToCheck[random]}
        coordX=${coords%,*}
        coordY=${coords#*,}
        leftToCheck=("${leftToCheck[@]:0:random}" "${leftToCheck[@]:random + 1}")
        validPaths=()
        center=$((coordY * rowSize * 2 + rowSize + coordX * 2 + 1))

        if [[ $coordX != 0 ]] && maze::isValidPath "$center" "$rowSize" "-1" "$board"; then
            validPaths[${#validPaths[@]}]="-1,0"
        fi

        if [[ $coordX != "$minX" ]] && maze::isValidPath "$center" "$rowSize" "1" "$board"; then
            validPaths[${#validPaths[@]}]="1,0"
        fi

        if [[ $coordY != 0 ]] && maze::isValidPath "$center" "$rowSize" "-$rowSize" "$board"; then
            validPaths[${#validPaths[@]}]="0,-1"
        fi

        if [[ $coordY != "$minY" ]] && maze::isValidPath "$center" "$rowSize" "$rowSize" "$board"; then
            validPaths[${#validPaths[@]}]="0,1"
        fi

        case "${#validPaths[@]}" in
            2|3)
                # If there's other options, put this back in the list for later processing
                leftToCheck[${#leftToCheck[@]}]=$coords
                ;&

            1)
                random=$((RANDOM % ${#validPaths[@]}))
                delta=${validPaths[random]}
                center=$((center + ${delta#*,} * rowSize + ${delta%,*}))
                board=${board:0:center}' '${board:center + 1}
                lastX=$((coordX + ${delta%,*}))
                lastY=$((coordY + ${delta#*,}))
                leftToCheck[${#leftToCheck[@]}]=$lastX,$lastY
        esac
    done

    local "$1" && assign::array "$1" "$boardX" "$boardY" "$board" "$startX" "$startY" "$lastX" "$lastY"
}


# See if the player made their way to the exit.
#
# $1 - Exit coords "X,Y" in cells
# $2 - Number of moves.
# $3-$5 - Player data (x, y, direction)
#
# Returns true if the user found the exit.
maze::checkForExit() {
    if [[ "$3,$4" == "$1" ]]; then
        echo ""
        echo "Congratulations! You found your way out in $2 moves."

        return 0
    fi

    return 1
}


# Determines if it is acceptable to make a path connecting two cells.
#
# $1 - Index in the board data for the cell where we start
# $2 - The computed size of one row
# $3 - The amount of change in X
# $4 - The amount of change in Y
# $5 - Board data
#
# Returns true (0) when these two cells can be connected. Any other value
# indicates they should not be connected.
maze::isValidPath() {
    local centerIndex delta index rowSize

    centerIndex=$1
    rowSize=$2
    delta=$3
    board=$4
    shift 4

    # Move to the wall
    index=$((centerIndex + delta))

    if [[ "${board:index:1}" == " " ]]; then
        # Already a path in this direction
        return 1
    fi

    # Move to the middle of the tile we want to check
    index=$((index + delta))

    if [[ "${board:index - 1:1}${board:index + 1:1}${board:index - rowSize:1}${board:index + rowSize:1}" == *" "* ]]; then
        # Adjacent cell is already connected
        return 1
    fi

    return 0
}


# Creates a maze board array structure. Does not connect cells.
#
# $1 - Destination variable name for the board array
# $2 - Width of board in cells
# $3 - Height of board in cells
maze::makeMazeBoard() {
    local board cells divider rowsLeft x y

    x=$2
    y=$3
    rowsLeft=$3

    maze::makeMazeLine divider "$x" "+" "-+"
    maze::makeMazeLine cells "$x" "|" " |"
    board="$divider"

    while [[ $rowsLeft -gt 0 ]]; do
        rowsLeft=$((rowsLeft - 1))
        board+="$cells$divider"
    done

    local "$1" && assign::array "$1" "$x" "$y" "$board"
}


# Creates a single line of a maze board.
#
# $1 - Destination variable name.
# $2 - Length of line in cells.
# $3 - Starting string for the line.
# $4 - String to append for each cell.
maze::makeMazeLine() {
    local len line

    len=$2
    line=$3

    while [[ $len -gt 0 ]]; do
        len=$((len - 1))
        line+=$4
    done

    local "$1" && assign::value "$1" "$line"
}


# Creates a maze board array, complete with tunnels, the start point and end
# point.
#
# $1 - Destination variable name for the board data.
# $2 - Width of board in cells.
# $3 - Height of board in cells.
maze::makeMaze() {
    local boardData
    # local result startPos

    # Width and height in the number of cells
    maze::makeMazeBoard boardData "$2" "$3"

    # Make corridors
    maze::carvePaths boardData "${boardData[@]}"

    local "$1" && assign::array "$1" "${boardData[@]}"
}


# Attempt to move the player in the indicated direction.
#
# $1 - Destination variable name for the position data.
# $2 - Move direction, either 1 or -1
# $3-$5 - Position data
# $6-$@ - Board data
maze::move() {
    local board boardX index moveX moveY playerDir playerX playerY rowSize stepDir target

    target=$1
    stepDir=$2
    playerX=$3
    playerY=$4
    playerDir=$5
    boardX=$6
    board=$8
    rowSize=$((boardX * 2 + 1))
    index=$((rowSize + playerY * rowSize * 2 + playerX * 2 + 1))

    case "$playerDir" in
        0)
            moveX=0
            moveY=$((- stepDir))
            ;;

        1)
            moveX=$stepDir
            moveY=0
            ;;

        2)
            moveX=0
            moveY=$stepDir
            ;;

        3)
            moveX=$((- stepDir))
            moveY=0
            ;;
    esac

    if [[ "${board:index + rowSize * moveY + moveX:1}" != " " ]]; then
        return 1
    fi

    playerX=$((playerX + moveX))
    playerY=$((playerY + moveY))

    local "$target" && assign::array "$target" "$playerX" "$playerY" "$playerDir"
    return 0
}


# Reads a key from the keyboard and maps it to a code.
#
# $1 - Destination variable name for the code.
maze::readKey() {
    local code key

    readkey::code key

    case "$key" in
        # Arrow, vi, vi+shift, wasd, wasd+shift, numberPad
        ARROW_UP|k|K|w|W|8)
            code=FORWARD
            ;;

        ARROW_LEFT|h|H|a|A|4)
            code=LEFT
            ;;

        ARROW_RIGHT|l|L|d|D|6)
            code=RIGHT
            ;;

        ARROW_DOWN|j|J|s|S|5|2)
            code=BACK
            ;;

        "?")
            code=HELP
            ;;

        ESCAPE|q|Q|x|X|$'\x18')
            code=EXIT
            ;;

        *)
            code=UNKNOWN
            ;;
    esac

    local "$1" && assign::value "$1" "$code"
}


# Sets the initial position for the player
#
# $1 - Destination variable name for the position data array.
# $2-$@ - The board information
maze::setInitialPosition() {
    local board boardX boardY dir directions index offset offsetList random rowSize spot startX startY

    boardX=$2
    boardY=$3
    board=$4
    startX=$5
    startY=$6
    rowSize=$((1 + boardX * 2))
    index=$((rowSize + startY * 2 * rowSize + 1 + startX * 2))
    directions=0123

    while true; do
        random=$((RANDOM % ${#directions}))
        dir=${directions:random:1}
        offsetList=("-$rowSize" 1 "$rowSize" -1)
        offset=${offsetList[dir]}
        spot=${board:index + offset:1}

        if [[ "$spot" == " " ]]; then
            local "$1" && assign::array "$1" "$startX" "$startY" "$dir"
            return
        fi

        directions="${directions:0:random}${directions:random + 1}"
    done
}


# Display a maze board.
#
# $@ - The maze board array, optionally followed by the position array.
maze::showBoardData() {
    local board exitColor index line lines marker markerColor rowSize startColor x y

    x=$1
    board=$3
    rowSize=$((2 * x + 1))
    lines=()

    while [[ -n "$board" ]]; do
        lines[${#lines[@]}]=${board:0:rowSize}
        board=${board:rowSize}
    done

    if [[ -n "$8" ]]; then
        # Position array
        marker="^>v<"
        marker=${marker:${10}:1}
        y=$((1 + $9 * 2))
        lines[$y]="${lines[y]:0:1 + $8 * 2}$marker${lines[y]:2 + $8 * 2}"
    elif [[ -n "$4" ]]; then
        # Starting position
        y=$((1 + $5 * 2))
        lines[$y]="${lines[y]:0:1 + $4 * 2}*${lines[y]:2 + $4 * 2}"
    fi

    if [[ -n "$6" ]]; then
        y=$((1 + $7 * 2))
        lines[$y]="${lines[y]:0:1 + $6 * 2}X${lines[y]:2 + $6 * 2}"
    fi

    if [[ -n "$marker" ]]; then
        markerColor=$(ansi --no-newline --bg-blue --yellow --bold "$marker")
    else
        # Does not match anything
        marker="XXX"
        markerColor="XXX"
    fi

    startColor=$(ansi --no-newline --yellow --bold "*")
    exitColor=$(ansi --no-newline --green --bold X)

    for line in "${lines[@]}"; do
        line=${line/$marker/$markerColor}
        line=${line/\*/$startColor}
        line=${line/X/$exitColor}
        echo "$line"
    done
}


# Turns the character 90 degrees
#
# $1 - Destination variable for the new position
# $2 - Turn direction, -1 is left and 1 is right
# $3-$@ - Position array elements
maze::turn() {
    local dir

    dir=$(($5 + $2))

    case "$dir" in
        -1)
            dir=3
            ;;
        4)
            dir=0
            ;;
    esac

    local "$1" && assign::array "$1" "$3" "$4" "$dir"
}


maze() {
    local board boardRows exitCoords moves position

    maze::makeMaze board 20 10
    maze::setInitialPosition position "${board[@]}"
    maze::showBoardData "${board[@]}" "${position[@]}"
    boardRows=$((board[1] * 2 + 1))
    exitCoords="${board[5]},${board[6]}"
    moves=0

    while maze::readKey key; do
        case "$key" in
            FORWARD)
                maze::move position 1 "${position[@]}" "${board[@]}" && moves=$((moves + 1))
                maze::checkForExit "$exitCoords" "$moves" "${position[@]}" && return
                ansi::up "$boardRows"
                ;;

            LEFT)
                ansi::up "$boardRows"
                maze::turn position -1 "${position[@]}"
                ;;

            RIGHT)
                ansi::up "$boardRows"
                maze::turn position 1 "${position[@]}"
                ;;

            BACK)
                maze::move position -1 "${position[@]}" "${board[@]}" && moves=$((moves + 1))
                maze::checkForExit "$exitCoords" "$moves" "${position[@]}" && return
                ansi::up "$boardRows"
                ;;

            HELP)
                ansi::up "$boardRows"
                ansi::eraseDisplay 0
                echo ""
                echo "Navigate through the maze. Try to find the exit."
                echo ""
                echo "Up, W, K, 8 = Move forward."
                echo "Down, S, J, 5, 2 = Move backward."
                echo "Left, A, H, 4 = Turn left."
                echo "Right, D, L, 6 = Turn right."
                echo "Escape, Q, X = Leave game."
                echo ""
                ;;

            EXIT)
                echo ""
                echo "Thanks for playing!"

                return
                ;;

            UNKNOWN)
                ansi::up "$boardRows"
                ansi::eraseDisplay 0
                echo ""
                echo "Sorry, I do not understand that command. Press ? for help."
                echo ""
                ;;
        esac

        maze::showBoardData "${board[@]}" "${position[@]}"
    done
}


if ! bpm::isSourced; then
    # Disabling locale settings makes this marginally faster
    LC_ALL=C LANG=C maze "$@"
fi
